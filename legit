----------------------script start-------------------------------

--some functions--

function Notify(tt, tx)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = tt,
        Text = tx,
        Duration = 4
    })
end
function getcurrentgun(plr)
    local char = plr.Character
    if not char then return nil, nil end
    local invchar = game.ReplicatedStorage.Players:FindFirstChild(game.Players.LocalPlayer.Name).Inventory
    if not invchar then return nil, nil end

    local gun = nil
    local gunname = nil
    local guninv = nil

    for _, desc in ipairs(char:GetDescendants()) do
        if desc:IsA("Model") and desc:FindFirstChild("ItemRoot") and desc:FindFirstChild("Attachments") then
            gun = desc
            gunname = desc.Name
            guninv = invchar:FindFirstChild(gunname)
        end
    end

    return gunname, gun, guninv
end
function getcurrentammo(gun)
    if not gun then return nil end
    local loadedfold = gun:FindFirstChild("LoadedAmmo", true)
    if not loadedfold then return nil end
    local firstammo = loadedfold:FindFirstChild("1")
    if not firstammo then return nil end

    local ammoname = firstammo:GetAttribute("AmmoType")
    local ammo = game.ReplicatedStorage.AmmoTypes:FindFirstChild(ammoname)
    if not ammo then return nil end

    return ammo
end

--startup--

print("Loading start")

if _G.lovelyx then
    Notify("lovelyx", "Script is already loaded")
    return
end

local exec = identifyexecutor()
if string.match(exec, "Synapse") == nil and string.match(exec, "Macsploit") == nil and string.match(exec, "Seliware") == nil and string.match(exec, "Nihon") == nil and string.match(exec, "Swift") == nil then

    local reqtest = pcall(function()
        require(game.ReplicatedStorage.Modules.FPS)
    end)
    local filetest = pcall(function()
        isfile("lovelyx1runCheck.mp3")
    end)
    local connecttest = pcall(function()
        getconnections(game.ChildAdded)
    end)

    local libtest = pcall(function()
        local drawing1 = Drawing.new("Square")
        drawing1.Visible = false
        drawing1:Destroy()
    end)
    if libtest == false then
        Notify("lovelyx", "Wait while we install drawing lib for you")
        local lib = game:HttpGet("https://drive.google.com/uc?export=download&id=1xDwhcJeZMMaGsOhRTM1oZw0TgklkDIwP")
        loadstring(lib)()
        Notify("lovelyx", "Drawing lib installed!, Script is loading")
    else
        Notify("lovelyx", "Loading. Using " .. exec .. " (Half supported)")
    end

    Notify("WARNING", "We do not guarantee that the script will work on your injector!")
else
    Notify("lovelyx", "Loading. Using " .. exec .. " (Full supported)")
end

if not isfile("lovelyxCross.png") then
    writefile("lovelyxCross.png", game:HttpGet("https://drive.google.com/uc?export=download&id=1YPcs7LGL2z0D13iBdaSoZuDKRfxgQm9R"));
end

if game.Players.LocalPlayer.Character == nil or not game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
    Notify("lovelyx", "It looks like the game has not loaded yet, the script is waiting for the game to load")

    while game.Players.LocalPlayer.Character == nil or not game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") do
        wait(0.2)
    end
end
wait(0.5)

print("loading variables ")

--variables--

local wcamera = workspace.CurrentCamera
local localplayer = game.Players.LocalPlayer
local runs = game:GetService("RunService")
local uis = game:GetService("UserInputService")
local scriptloading = true
local ACBYPASS_SYNC = false
local keybindlist = true
local keylist_gui 
local keylist_items = {}

local aimbool = true
local aimdebug1 = false
local aimdebug2 = false
local aimdebug3 = false
local aimselftrack = false
local aimbots = true
local aimvischeck = false
local aimdistcheck = false
local aimbang = true
local aimtrigger = false
local aiminfrange = false
local aimtarget = nil
local aimtargetpart = nil
local aimdynamicfov = false
local aimpart = "Head"
local aimtype = "Instant Hit"
local aimfov = 100
local aimdistance = 800 -- meters
local aimchance = 100
local aimfakewait = 0
local aimfovcircle = Drawing.new("Circle")
local aimtargetname = Drawing.new("Text")
local aimtargetshots = Drawing.new("Text")
local aimogfunc = require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet
local aimmodfunc -- will change later in script
local aimignoreparts = {}
for i,v in ipairs(workspace:GetDescendants()) do
    if v:GetAttribute("PassThrough") then
        table.insert(aimignoreparts, v)
    end
end

local selftrack_data = {}
local selftrack_update = 0

local rapidfire = false
local unlockmodes = false
local multitaps = 1
local instrelOGfunc = require(game.ReplicatedStorage.Modules.FPS).reload
local instrelMODfunc -- changed later

local aimFRIENDLIST = {}
local friendlistmode = "Blacklist"
local friendlistbots = false

local esptextcolor = Color3.fromRGB(255,255,255)
local esptable = {}
--[[ esptable template
    drawingobj = {
        primary = instance
        type = string --(highlight, name, hp, hotbar, distance, skelet, box)
        otype = string --(plr, bot, dead, extract, loot)
    }      
]] 
local espbool = true
local espname = true
local esphp = true
local espdistance = true
local espdistmode = "Meters"
local espbots = true
local esphigh = false
local espdead = false
local esphotbar = true
local esploot = false
local espexit = false
local esptextline = false
local esprenderdist = 1000 -- meters
local espchamsfill = 0.5
local espchamsline = 0
local esptextsize = 14
local espboxcolor = Color3.fromRGB(255,255,255)
local espfillcolor = Color3.fromRGB(255,0,0)
local esplinecolor = Color3.fromRGB(255,255,255)

local invcheck = false
local invchecktext = Drawing.new("Text")

local tracbool = true
local tracwait = 2
local traccolor = Color3.fromRGB(255,255,255)
local tractexture = "Lightning"
local tractextures = {
    ["None"] = nil,
    ["Glow"] = "http://www.roblox.com/asset/?id=78260707920108",
    ["Lighting"] = "http://www.roblox.com/asset/?id=131326755401058",
}

local crossbool = true
local crosscolor = Color3.fromRGB(255,255,255)
local crosssizeog = UDim2.new(0.017, 0, 0.03, 0)
local crosssizek = 0.1
local crossrot = 5
local crossimg = getcustomasset("lovelyxCross.png")
local crossgui = Instance.new("ScreenGui", localplayer.PlayerGui)
crossgui.ClipToDeviceSafeArea = false
crossgui.ResetOnSpawn = false
crossgui.ScreenInsets = 0
local crosshair = Instance.new("ImageLabel", crossgui)
crosshair.AnchorPoint = Vector2.new(0.5, 0.5)
crosshair.Position = UDim2.new(0.5, 0, 0.5, 0)
crosshair.Size = UDim2.new(crosssizeog.X.Scale * crosssizek, 0, crosssizeog.Y.Scale * crosssizek, 0)
crosshair.Image = crossimg
crosshair.ImageColor3 = crosscolor
crosshair.BackgroundTransparency = 1
crosshair.Visible = false

local camthirdp = false
local camthirdpX = 2
local camthirdpY = 2
local camthirdpZ = 5
local basefov = 120
local zoomfov = 5
local camzoomfunctionOG = require(game.ReplicatedStorage.Modules.CameraSystem).SetZoomTarget
local camzoomfunction --changed later

local viewmod_materials = {
    ["Forcefield"] = Enum.Material.ForceField,
    ["Neon"] = Enum.Material.Neon,
    ["Plastic"] = Enum.Material.SmoothPlastic
}
local viewmodbool = false
local viewmodhandmat = Enum.Material.Plastic
local viewmodgunmat = Enum.Material.Plastic
local viewmodhandcolor = Color3.fromRGB(255,255,255)
local viewmodguncolor = Color3.fromRGB(255,255,255)
local viewmodoffset = false
local viewmodX = -2
local viewmodY = -2
local viewmodZ = 0

local scbool = false
local scgui = nil --later
local scselected = nil

local speedbool = false
local speedboost = 1.2
local nojumpcd = false
local nofall = false
local changerbool = false
local changergrav = 95
local changerspeed = 20
local changerheight = 2
local changerjump = 3
local charsemifly = false
local charsemiflydist = 6
local charsemiflyspeed = 30
local semifly_bodyvel = nil
local semifly_pos = CFrame.new()
local semifly_posconnect = nil
local instantleanOGfunc --changed later
local instantleanMODfunc --changed later

local folcheck = workspace:FindFirstChild("SpawnerZones")
local worldclock = 14
local waterplatforms = Instance.new("Folder", workspace)
waterplatforms.Name = "lovelyxWaterPlatforms"
local worldjesus

local espmapactive = false
local handleESPMAP = function() do end end
local espmapmarkers = {}
local detectedmods = {}
local detectmods = false

local valcache = {
    ["6B45"] = 16,
    ["AS Val"] = 16,
    ["ATC Key"] = 6,
    ["Airfield Key"] = 6,
    ["Altyn"] = 16,
    ["Altyn Visor"] = 8,
    ["Maska Visor"] = 8,
    ["Attak-5 60L"] = 16,
    ["Bolts"] = 1,
    ["Crane Key"] = 6,
    ["DAGR"] = 12,
    ["Duct Tape"] = 1,
    ["Fast MT"] = 10,
    ["Flare Gun"] = 20,
    ["Fueling Station Key"] = 2,
    ["Garage Key"] = 4,
    ["Hammer"] = 1,
    ["JPC"] = 10,
    ["Lighthouse Key"] = 6,
    ["M4A1"] = 12,
    ["Nails"] = 1,
    ["Nuts"] = 1,
    ["Saiga 12"] = 8,
    ["Super Glue"] = 1,
    ["Village Key"] = 2,
    ["Wrench"] = 1,
    ["SPSh-44"] = 12,
    ["R700"] = 16,
    ["AKMN"] = 12,
    ["Mosin"] = 12,
    ["SVD"] = 12,
    ["7.62x39AP"] = 0.15,
    ["7.62x54AP"] = 0,15,
}
--drawing setup--

aimfovcircle.Visible = false
aimfovcircle.Radius = aimfov
aimfovcircle.Thickness = 2
aimfovcircle.Filled = false
aimfovcircle.Transparency = 1
aimfovcircle.Color = Color3.fromRGB(255, 255, 255)
aimfovcircle.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
aimtargetname.Text = "None"
aimtargetname.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2 + aimfov + 20) 
aimtargetname.Size = 24
aimtargetname.Color = Color3.fromRGB(255,255,255)
aimtargetname.Visible = false
aimtargetname.Center = true
aimtargetname.Outline = true
aimtargetname.OutlineColor = Color3.new(0, 0, 0)
aimtargetshots.Text = " "
aimtargetshots.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2 + aimfov + 30) 
aimtargetshots.Size = 20
aimtargetshots.Color = Color3.fromRGB(255,255,255)
aimtargetshots.Visible = false
aimtargetshots.Center = true
aimtargetshots.Outline = true
aimtargetshots.OutlineColor = Color3.new(0, 0, 0)
invchecktext.Text = " "
invchecktext.Position = Vector2.new(100, wcamera.ViewportSize.Y / 2)
invchecktext.Size = 18
invchecktext.Color = Color3.fromRGB(255,255,255)
invchecktext.Visible = true
invchecktext.Center = false
invchecktext.Outline = true
invchecktext.OutlineColor = Color3.new(0, 0, 0)

--gui setup--

if _G.lovelyx then
    Notify("lovelyx", "Script is already loaded")
    return
end

print('loading gui library')
--gui library load--
local library = nil
task.spawn(function()
    local newlib = loadstring(game:HttpGet("https://raw.githubusercontent.com/oShyyyyy/Plaguecheat.cc-Roblox-Ui-library/main/Source.lua", true))()

    if library ~= nil then 
        newlib.GUI:Destroy()
        return 
    end
    library = newlib

    if game.CoreGui:FindFirstChild("PCR_1") then
        game.CoreGui.PCR_1.Enabled = false
    end
end)
task.wait(2)
while library == nil do
    task.spawn(function()
        local newlib = loadstring(game:HttpGet("https://raw.githubusercontent.com/oShyyyyy/Plaguecheat.cc-Roblox-Ui-library/main/Source.lua", true))()

        if library ~= nil then 
            newlib.GUI:Destroy()
            return 
        end
        library = newlib
    
        if game.CoreGui:FindFirstChild("PCR_1") then
            game.CoreGui.PCR_1.Enabled = false
        end
    end)

    task.wait(2)
    if library == nil then
        continue
    end
end
if _G.lovelyx then
    return
end
_G.lovelyx = true
game.CoreGui.PCR_1.Enabled = false
do
    local bg = game.CoreGui.PCR_1:FindFirstChild("BG", true)
    if bg then 
        Instance.new("UICorner", bg.Parent).CornerRadius = UDim.new(0.02, 0)
    end
end
library.GUI.ScreenInsets = Enum.ScreenInsets.None
local librarymaingui = library.GUI.MAIN


--keybind list--
print('loading keybind list')
do
    local a=Instance.new"Frame"
    a.Name="Keybinds"
    a.Size=UDim2.new(0.099531,0,0.2842593,0)
    a.BorderColor3=Color3.fromRGB(0,0,0)
    a.Position=UDim2.new(0.0057322,0,0.0495185,0)
    a.BorderSizePixel=0
    a.BackgroundColor3=Color3.fromRGB(44,44,44)
    a.Visible = false
    local b=Instance.new"UICorner"
    b.CornerRadius=UDim.new(0.05,0)
    b.Parent=a
    local c=Instance.new"UIStroke"
    c.ApplyStrokeMode=1
    c.Thickness=2.5999999
    c.Color=Color3.fromRGB(91,133,197)
    c.Parent=a
    local d=Instance.new"Frame"
    d.Name="Title"
    d.Size=UDim2.new(0.9994792,0,0.0781759,0)
    d.BorderColor3=Color3.fromRGB(0,0,0)
    d.BackgroundTransparency=0.75
    d.Position=UDim2.new(0,0,0,0)
    d.BorderSizePixel=0
    d.BackgroundColor3=Color3.fromRGB(0,0,0)
    d.Parent=a
    local e=Instance.new"TextLabel"
    e.Name="Label"
    e.Size=UDim2.new(0.7853403,0,0.7083333,0)
    e.BorderColor3=Color3.fromRGB(0,0,0)
    e.BackgroundTransparency=1
    e.Position=UDim2.new(0.1046575,0,0.144544,0)
    e.BorderSizePixel=0
    e.BackgroundColor3=Color3.fromRGB(255,255,255)
    e.FontSize=5
    e.TextStrokeTransparency=0
    e.TextSize=14
    e.RichText=true
    e.TextColor3=Color3.fromRGB(255,255,255)
    e.Text="Keybinds"
    e.TextWrapped=true
    e.TextWrap=true
    e.Font=100
    e.TextScaled=true
    e.Parent=d
    local f=Instance.new"UICorner"
    f.CornerRadius=UDim.new(0.5,0)
    f.Parent=d
    local g=Instance.new"Frame"
    g.Name="Items"
    g.Size=UDim2.new(0.9105204,0,0.8794788,0)
    g.BorderColor3=Color3.fromRGB(0,0,0)
    g.BackgroundTransparency=0.75
    g.Position=UDim2.new(0.041863,0,0.0977199,0)
    g.BorderSizePixel=0
    g.BackgroundColor3=Color3.fromRGB(0,0,0)
    g.Parent=a
    local h=Instance.new"UICorner"
    h.CornerRadius=UDim.new(0.05,0)
    h.Parent=g
    local i=Instance.new"UIStroke"
    i.ApplyStrokeMode=1
    i.Thickness=1.8
    i.Color=Color3.fromRGB(54,54,54)
    i.Parent=g
    local j=Instance.new"UIListLayout"
    j.SortOrder=2
    j.Wraps=true
    j.HorizontalFlex=2
    j.ItemLineAlignment=2
    j.Padding=UDim.new(0.02,0)
    j.Parent=g
    local k=Instance.new"Configuration"
    k.Name="Templates"
    k.Parent=a
    local l=Instance.new"TextLabel"
    l.Name="Keytemplate"
    l.Size=UDim2.new(0.9080459,0,0.08,0)
    l.BorderColor3=Color3.fromRGB(0,0,0)
    l.BackgroundTransparency=1
    l.Position=UDim2.new(0.091954,0,0,0)
    l.BorderSizePixel=0
    l.BackgroundColor3=Color3.fromRGB(255,255,255)
    l.FontSize=5
    l.TextStrokeTransparency=0
    l.TextSize=14
    l.TextColor3=Color3.fromRGB(255,255,255)
    l.Text="[Insert] Toggle GUI"
    l.TextWrapped=true
    l.TextWrap=true
    l.Font=100
    l.TextXAlignment=0
    l.TextScaled=true
    l.Parent=k

    a.Parent = library.GUI
    keylist_gui = a
end
local function keylist_removekey(funcname)
    local oldkey = keylist_items[funcname]
    if oldkey == nil then return end
    oldkey:Destroy()
end
local function keylist_addkey(funcname, keyname)
    local newkey = keylist_gui.Templates.Keytemplate:Clone()
    newkey.Name = funcname
    newkey.Text = '['..keyname..'] '..funcname
    newkey.Parent = keylist_gui.Items
    keylist_items[funcname] = newkey
end

print('setting up gui')

library:ChangeWeb("love zai")
library:ChangeGame("Project Delta")

local home = library:AddWindow('Home')
local combat = library:AddWindow('Combat')
local visual = library:AddWindow('Visuals')
local other = library:AddWindow('Other')
local editwatermark
editwatermark = library.GUI.ChildAdded:Connect(function(ch)
    if ch:IsA("Frame") then
        ch.AnchorPoint = Vector2.new(0.5, 0.5)
        ch.Position = UDim2.new(0.5, 0, 0.05, 0)
        Instance.new("UICorner", ch).CornerRadius = UDim.new(0.2, 0)
    end
    editwatermark:Disconnect()
end)

local mainhome = home:AddSection('Info')
local aim = combat:AddSection('Aim')
local gunmods = combat:AddSection('Gun Mods')
local tarinfo = combat:AddSection('Target')
local wh = visual:AddSection('ESP')
local cross = visual:AddSection('Crosshair')
local tracers = visual:AddSection('Tracers')
local camer = visual:AddSection('Camera')
local viewmod = visual:AddSection('View Model')
local speedh = other:AddSection('Character')
local worldh = other:AddSection('World')
local vmisc = other:AddSection('Misc')


mainhome:AddLabel('The script version is "lx-1" ')
mainhome:AddKeyBind('Toggle GUI', Enum.KeyCode.Insert, function() 
    if scriptloading then return end
    librarymaingui.Visible = not librarymaingui.Visible
    if scgui and scbool then
        scgui.Visible = librarymaingui.Visible
    end
end)
mainhome:AddToggle('Keybind list', true, nil, function(v)
    keybindlist = v
    keylist_gui.Visible = v
end)

aim:AddLabel('No Recoil/Spread enables with Silent Aim')
aim:AddToggle('Silent Aim', false, nil, function(v)
    aimbool = v
    if v == true then
        require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet = aimmodfunc
    else
        require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet = aimogfunc
    end
end)
aim:AddToggle('Visibility check', true, nil, function(v)
    aimvischeck = v
end)
aim:AddToggle('Ping check', true, nil, function(v)
    aimselftrack = v
end)
aim:AddToggle('Ammo distance check', true, nil, function(v)
    aimdistcheck = v
end)
aim:AddToggle('Target AI', true, nil, function(v)
    aimbots = v
end)
aim:AddToggle('Fake wait (instant hit only)', false, nil, function(v)
    aimfakewait = v
end)
aim:AddToggle('Dynamic FOV', false, nil, function(v)
    aimdynamicfov = v
end)
aim:AddSlider('Aim FOV', 250, 0, 90, function(c) 
    aimfov = c
end)
aim:AddSlider('Aim Distance (Meters)', 950, 50, 800, function(c) 
    aimdistance = c
end)
aim:AddSlider('Hit Chance', 100, 0, 60, function(c) 
    aimchance = c
end)
aim:AddDropdown('Aim Part', {
    'Head', 
    'HeadTop', 
    'Face', 
    'Torso', 
    'Scripted', 
    'Random', 
    'HeadTopHitBox', 
    'FaceHitBox', 
    'UpperTorso', 
    'LowerTorso', 
    'LeftUpperArm', 
    'RightUpperArm', 
    'LeftLowerArm', 
    'RightLowerArm', 
    'LeftHand', 
    'RightHand', 
    'LeftUpperLeg', 
    'RightUpperLeg', 
    'LeftLowerLeg', 
    'RightLowerLeg', 
    'LeftFoot', 
    'RightFoot'
}, 'Head', function(a)
    aimpart = a
end)
aim:AddDropdown('Aim Type', {'Prediction', 'Instant Hit'}, 'Instant Hit', function(a)
    aimtype = a
end)
aim:AddSeparateBar()
aim:AddToggle('Show FOV', true, nil, function(v)
    aimfovcircle.Visible = v
end)
aim:AddColorPallete('FOV Color', Color3.fromRGB(255, 255, 255),function(a) 
   aimfovcircle.Color = a
end)


gunmods:AddToggle('Rapid Fire [IF HOLD GUN - REEQUIP IT]', true, nil, function(v)
    rapidfire = v
    if v == true then
        local inv = game.ReplicatedStorage.Players:FindFirstChild(localplayer.Name).Inventory
        for i,v in ipairs(inv:GetChildren()) do
            local sett = require(v.SettingsModule)
            sett.FireRate = 0.002
        end
    else
        local inv = game.ReplicatedStorage.Players:FindFirstChild(localplayer.Name).Inventory
        for i,v in ipairs(inv:GetChildren()) do
            local sett = require(v.SettingsModule)
            local toset = 0.05
            toset = 60 / v.ItemProperties.Tool:GetAttribute("FireRate")
            sett.FireRate = toset
        end
    end
end)
gunmods:AddToggle('Unlock firemodes [IF HOLD GUN - REEQUIP IT]', true, nil, function(v)
    unlockmodes = v
end)
gunmods:AddSlider('Multitaps', 5, 1, 1,function(c)
    multitaps = c
end)


tarinfo:AddLabel('If it shows the name of target, then target is visible ')
tarinfo:AddToggle('Show Name', true, nil, function(v)
    aimtargetname.Visible = v
end)
tarinfo:AddToggle('Shots left', true, nil, function(v)
    aimtargetshots.Visible = v
end)


friendman:AddTextBox('Add name', nil, false, 5, function(plrname) 
    if game.Players:FindFirstChild(plrname) or workspace.AiZones:FindFirstChild(plrname, true) then 
        if table.find(aimFRIENDLIST, plrname) ~= nil then return end
        table.insert(aimFRIENDLIST, plrname)
        Notify("lovelyx", "Added "..plrname.." to friendlist" )
    end
end)
friendman:AddTextBox('Remove name', nil, false, 5, function(plrname)
    local iter = table.find(aimFRIENDLIST, plrname)
    if iter ~= nil then 
        table.remove(aimFRIENDLIST, iter)
        Notify("lovelyx", "Removed "..plrname.." from friendlist" )
    end
end)
friendman:AddToggle('Include bots', true, nil, function(v)
    friendlistbots = v
end)
friendman:AddDropdown('Friendlist mode', {'Blacklist', 'Whitelist'}, 'Blacklist', function(a)
    friendlistmode = a
end)
friendman:AddButton('Print friendlist (console)',function()
    if #aimFRIENDLIST == 0 then 
        print("No one in friendlist")
        return
    end
    print("lovelyx friendlist:")
    for i,v in aimFRIENDLIST do
        print("["..i.."] "..v)
    end
    print("lovelyx friendlist end")
end)
friendman:AddButton('Clear friendlist',function()
    table.clear(aimFRIENDLIST)
end)


wh:AddToggle('ESP', true, nil, function(v)
    espbool = v
end)
wh:AddToggle('Name', true, nil, function(v)
    espname = v
end)
wh:AddToggle('HP', true, nil, function(v)
    esphp = v
end)
wh:AddToggle('Distance', true, nil, function(v)
    espdistance = v
end)
wh:AddToggle('Chams', true, nil, function(v)
    esphigh = v
end)
wh:AddToggle('Active Gun', true, nil, function(v)
    esphotbar = v
end)
wh:AddToggle('Dead', true, nil, function(v)
    espdead = v
end)
wh:AddToggle('Bots', true, nil, function(v)
    espbots = v
end)
wh:AddToggle('Loot', true, nil, function(v)
    esploot = v
end)
wh:AddToggle('Extract', true, nil, function(v)
    espexit = v
end)
wh:AddDropdown('Distance type', {'Meters', 'Studs'}, 'Meters', function(a)
    espdistmode = a
end)
wh:AddSlider('Render Distance (Meters)', 1200, 50, 1000, function(c) 
    esprenderdist = c
end)
wh:AddSlider('Text Size', 35, 1, 14, function(c) 
    esptextsize = c
end)
wh:AddToggle('Text outline', true, nil, function(v)
    esptextline = v
end)
wh:AddSlider('Chams Outline Transparency', 1, 0, 0, function(c) 
    espchamsline = c
end)
wh:AddSlider('Chams Fill Transparency', 1, 0, 0.5, function(c) 
    espchamsfill = c
end)
wh:AddColorPallete('Text Color', Color3.fromRGB(255, 255, 255),function(a) 
    esptextcolor = a
end)
wh:AddColorPallete('Chams Outline Color', Color3.fromRGB(255, 255, 255),function(a) 
    esplinecolor = a
end)
wh:AddColorPallete('Chams Fill Color', Color3.fromRGB(255, 255, 255),function(a) 
    espfillcolor = a
end)


cross:AddToggle('Crosshair', true, nil, function(v)
    crossbool = v
end)
cross:AddLabel('Example: lovelyxCross.png (put image from workspace)')
cross:AddTextBox('Image', nil, false, 5, function(a) 
    if isfile(a) then
        if getcustomasset(a) ~= nil then
            crossimg = getcustomasset(a)
        else
            Notify("lovelyx Error", "File is not a image")
            return
        end
    else
        Notify("lovelyx Error", "Cant find the image")
        return
    end
end)
cross:AddSlider('Size', 30, 0.5, 2, function(c) 
    crosssizek = c
end)
cross:AddSlider('Rotation Speed', 10, -10, 0, function(c) 
    crossrot = c
end)
cross:AddColorPallete('Color', Color3.fromRGB(255, 255, 255),function(a) 
    crosscolor = a
end)


tracers:AddToggle('Enabled', true, nil, function(v)
    tracbool = v
end)
tracers:AddSlider('Remove time', 10, 0, 2, function(c) 
    tracwait = c
end)
tracers:AddColorPallete('Tracers Color', Color3.fromRGB(255, 255, 255),function(a) 
    traccolor = a
end)
tracers:AddDropdown('Texture', {'None', 'Lighting', "Glow"}, 'None', function(a)
    tractexture = tractextures[a]
end)


camer:AddToggle('Third Person', true, Enum.KeyCode.KeypadSix, function(v)
    if v then keylist_addkey("Third Person", Enum.KeyCode.KeypadSix.Name) else keylist_removekey("Third Person") end

    camthirdp = v
    if v and localplayer.Character then
        localplayer.Character.Humanoid.CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
        localplayer.CameraMaxZoomDistance = 5
        localplayer.CameraMinZoomDistance = 5
    else
        localplayer.Character.Humanoid.CameraOffset = Vector3.new(0,0,0)
        localplayer.CameraMaxZoomDistance = 0.5
        localplayer.CameraMinZoomDistance = 0.5
    end
end)
camer:AddSlider('Offset X', 10, -10, 2, function(c) 
    camthirdpX = c
    if camthirdp and localplayer.Character then
        localplayer.Character.Humanoid.CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
    end
end)
camer:AddSlider('Offset Y', 10, -10, 2, function(c) 
    camthirdpY = c
    if camthirdp and localplayer.Character then
        localplayer.Character.Humanoid.CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
    end
end)
camer:AddSlider('Offset Z', 10, -10, 5, function(c) 
    camthirdpZ = c
    if camthirdp and localplayer.Character then
        localplayer.Character.Humanoid.CameraOffset = Vector3.new(camthirdpX, camthirdpY, camthirdpZ)
    end
end)
camer:AddSeparateBar()
camer:AddToggle('Anti mask', true, nil, function(v)
    if v == true then
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.HelmetMask.TitanShield.Size = UDim2.new(0,0,1,0)
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Mask.GP5.Size = UDim2.new(0,0,1,0)
        for i,v in ipairs(game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Visor:GetChildren()) do
            v.Size = UDim2.new(0,0,1,0)
        end
    else
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.HelmetMask.TitanShield.Size = UDim2.new(1,0,1,0)
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Mask.GP5.Size = UDim2.new(1,0,1,0)
        for i,v in ipairs(game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Visor:GetChildren()) do
            v.Size = UDim2.new(1,0,1,0)
        end
    end
end)
camer:AddToggle('Anti flash', true, nil, function(v)
    if v == true then
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Flashbang.Size = UDim2.new(0,0,1,0)
    else
        game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Flashbang.Size = UDim2.new(1,0,1,0)
    end
end)
camer:AddSeparateBar()
camer:AddToggle('Modify Zoom', true, nil, function(v)
    if scriptloading then return end

    if v == true then
        require(game.ReplicatedStorage.Modules.CameraSystem).SetZoomTarget = camzoomfunction
    else
        require(game.ReplicatedStorage.Modules.CameraSystem).SetZoomTarget = camzoomfunctionOG
    end
end)
camer:AddSlider('Base FOV', 150, 10, 120, function(c) 
    basefov = c
end)
camer:AddSlider('Zoom FOV', 50, 0, 5, function(c) 
    zoomfov = c
end)

viewmod:AddSeparateBar()



speedh:AddToggle('Jesus', true, nil, function(v)
    worldjesus = v
    if v then
        while worldjesus do
            wait(0.01)
            --original = https://devforum.roblox.com/t/how-do-i-make-water-walking-passive-like-this/1589924/10
            local hitPart = workspace:Raycast(localplayer.Character:FindFirstChild("HumanoidRootPart").Position, Vector3.new(0, -5, 0) + localplayer.Character:FindFirstChild("HumanoidRootPart").CFrame.LookVector * 5, RaycastParams.new())
            if hitPart and hitPart.Material == Enum.Material.Water then
                local clone = Instance.new("Part")
                clone.Parent = waterplatforms
                clone.Position = hitPart.Position
                clone.Anchored = true
                clone.CanCollide = true
                clone.Size = Vector3.new(10,0.2,10)
                clone.Transparency = 1
            end
        end
    else
        for i,v in ipairs(waterplatforms:GetChildren()) do
            v:Destroy()
        end
    end
end)

speedh:AddToggle('No Jump Cooldown', true, nil, function(v)
    nojumpcd = v
    startnojumpcd()
end)



vmisc:AddToggle('Inventory Checker', true, nil, function(v)
    invcheck = v
end)
vmisc:AddToggle('Mod notify', true, nil, function(v)
    if scriptloading then return end

    detectmods = v
    if v == false then
        table.clear(detectedmods)
    end
end)
vmisc:AddToggle('ESP Map', true, Enum.KeyCode.KeypadSeven, function(v)
    if scriptloading then return end
    if v then keylist_addkey("ESP Map", Enum.KeyCode.KeypadSeven.Name) else keylist_removekey("ESP Map") end

    espmapactive = v
    handleESPMAP(v)
end)




--tracers--
print("loading tracers")
local function runtracer(start, endp)
    local beam = Instance.new("Beam")
    beam.Name = "LineBeam"
    beam.Parent = game.Workspace
    local startpart = Instance.new("Part")
    startpart.CanCollide = false
    startpart.CanQuery = false
    startpart.Transparency = 1
    startpart.Position = start
    startpart.Parent = workspace
    startpart.Anchored = true
    startpart.Size = Vector3.new(0.01, 0.01, 0.01)
    local endpart = Instance.new("Part")
    endpart.CanCollide = false
    endpart.CanQuery = false
    endpart.Transparency = 1
    endpart.Position = endp
    endpart.Parent = workspace
    endpart.Anchored = true
    endpart.Size = Vector3.new(0.01, 0.01, 0.01)
    beam.Attachment0 = Instance.new("Attachment", startpart)
    beam.Attachment1 = Instance.new("Attachment", endpart)
    beam.Color = ColorSequence.new(traccolor,  traccolor)
    beam.Width0 = 0.05
    beam.Width1 = 0.05
    beam.FaceCamera = true
    beam.Transparency = NumberSequence.new(0)
    beam.LightEmission = 1

    if tractexture ~= nil then
        beam.Texture = tractexture
        if tractexture == "http://www.roblox.com/asset/?id=131326755401058" then
            beam.TextureSpeed = 3
            beam.TextureLength = (endp - start).Magnitude
            beam.Width0 = 0.3
            beam.Width1 = 0.3
        end
    end

    wait(tracwait)

    beam:Destroy()
    startpart:Destroy()
    endpart:Destroy()
end

--silent aim--
print("loading silent aim ")
local function isonscreen(object)
    local _, bool = wcamera:WorldToScreenPoint(object.Position)
    return bool
end
local v311 = require(game.ReplicatedStorage.Modules:WaitForChild("UniversalTables"))
local globalist11 = v311.ReturnTable("GlobalIgnoreListProjectile")
local function isvisible(char, object)
    if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    if aimvischeck == false then
        return true
    end

    local origin = localplayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1, 0)
    if aimselftrack then
        local plrping = localplayer:GetNetworkPing()
        local key = math.floor((plrping + 5) / 10) * 10

        if selftrack_data[key] ~= nil then
            origin = selftrack_data[key]
        end
    end

    local pos = object.Position
    local dir = pos - origin
    local dist = dir.Magnitude + 5
    local penetrated = true
    dir = dir.Unit

    local params = RaycastParams.new()
    params.IgnoreWater = true
    params.CollisionGroup = "WeaponRay"
    params.FilterDescendantsInstances = {
        localplayer.Character:GetChildren(),
        wcamera:GetChildren(),
        globalist11,
        aimignoreparts
    }

    local ray = workspace:Raycast(origin, dir * dist, params)
    if aimbang then
        if ray and ray.Instance:IsDescendantOf(char) then
            return true
        elseif ray and ray.Instance.Name ~= "Terrain" and not ray.Instance:GetAttribute("NoPen") then
            local armorpen4 = 10
            if globalammo then
                armorpen4 = globalammo:GetAttribute("ArmorPen")
            end

            local FunctionLibraryExtension = require(game.ReplicatedStorage.Modules.FunctionLibraryExtension)
            local armorpen1, newpos2 = FunctionLibraryExtension.Penetration(FunctionLibraryExtension, ray.Instance, ray.Position, dir, armorpen4)
            if armorpen1 == nil or newpos2 == nil then
                return false
            end

            local neworigin = ray.Position + dir * 0.01
            local newray = workspace:Raycast(neworigin, dir * (dist - (neworigin - origin).Magnitude), params)
            if newray and newray.Instance:IsDescendantOf(char) then
                return true
            end
        end
    else
        if ray and ray.Instance:IsDescendantOf(char) then
            return true
        end
    end

    return false
end
local function predictpos(tpart, bulletspeed, bulletdrop)
    local velocity = tpart.Velocity
    local distance = (wcamera.CFrame.Position - tpart.CFrame.Position).Magnitude
    local tth = (distance / bulletspeed)
    local predict1 = tpart.CFrame.Position + (velocity * tth)
    local delta = (predict1 - tpart.CFrame.Position).Magnitude
    local finalspeed = bulletspeed - 0.013 * bulletspeed ^ 2 * tth ^ 2
    tth += (delta / finalspeed)
    local predictres1 = tpart.CFrame.Position + (velocity * tth)
    local predictres2 = bulletdrop * tth ^ 2
    if tostring(drop_timing):find("nan") then
        predictres2 = 0
    end
    return predictres1 -- + Vector3.new(0,predictres2,0)
end
local function choosetarget()
    local cent = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
    local cdist = math.huge
    local ctar = nil
    local cpart = nil

    local ammodistance = 999999999
    if aimdistcheck and globalammo then
        ammodistance = globalammo:GetAttribute("MuzzleVelocity")
    end

    local bparts = {
        "Head",
        "HeadTopHitBox",
        "FaceHitBox",
        "UpperTorso",
        "LowerTorso",
        "LeftUpperArm",
        "RightUpperArm",
        "LeftLowerArm",
        "RightLowerArm",
        "LeftHand",
        "RightHand",
        "LeftUpperLeg",
        "RightUpperLeg",
        "LeftLowerLeg",
        "RightLowerLeg",
        "LeftFoot",
        "RightFoot"
    }

    local function chooseTpart(charact)
        if aimpart == "Head" then
            return charact:FindFirstChild("Head")
        elseif aimpart == "HeadTop" then
            return charact:FindFirstChild("HeadTopHitBox")
        elseif aimpart == "Face" then
            return charact:FindFirstChild("FaceHitBox")
        elseif aimpart == "Torso" then
            return charact:FindFirstChild("UpperTorso") -- Assuming "Torso" refers to UpperTorso
        elseif aimpart == "Random" then
            return charact:FindFirstChild(bparts[math.random(1, #bparts)])
        elseif aimpart == "UpperTorso" then
            return charact:FindFirstChild("UpperTorso")
        elseif aimpart == "LowerTorso" then
            return charact:FindFirstChild("LowerTorso")
        elseif aimpart == "LeftUpperArm" then
            return charact:FindFirstChild("LeftUpperArm")
        elseif aimpart == "RightUpperArm" then
            return charact:FindFirstChild("RightUpperArm")
        elseif aimpart == "LeftLowerArm" then
            return charact:FindFirstChild("LeftLowerArm")
        elseif aimpart == "RightLowerArm" then
            return charact:FindFirstChild("RightLowerArm")
        elseif aimpart == "LeftUpperLeg" then
            return charact:FindFirstChild("LeftUpperLeg")
        elseif aimpart == "RightUpperLeg" then
            return charact:FindFirstChild("RightUpperLeg")
        elseif aimpart == "LeftLowerLeg" then
            return charact:FindFirstChild("LeftLowerLeg")
        elseif aimpart == "RightLowerLeg" then
            return charact:FindFirstChild("RightLowerLeg")
        elseif aimpart == "Scripted" then
            local head = charact:FindFirstChild("Head")
            local upperTorso = charact:FindFirstChild("UpperTorso")
            if not isvisible(charact, head) then
                return upperTorso
            else
                return head
            end
        end
    end

    if aimbots then --priority 2 (bots)
        for _, botfold in ipairs(workspace.AiZones:GetChildren()) do
            for _, bot in ipairs(botfold:GetChildren()) do
                if bot:IsA("Model") and bot:FindFirstChild("Humanoid") and bot.Humanoid.Health > 0 then
                    if friendlistbots then
                        if friendlistmode == "Blacklist" then 
                            if table.find(aimFRIENDLIST, bot.Name) ~= nil then
                                continue
                            end
                        elseif friendlistmode == "Whitelist" then 
                            if table.find(aimFRIENDLIST, bot.Name) == nil then
                                continue
                            end
                        end
                    end

                    local potroot = chooseTpart(bot)
                    if potroot and localplayer.Character then
                        local spoint = wcamera:WorldToViewportPoint(potroot.Position)
                        local optpoint = Vector2.new(spoint.X, spoint.Y)
                        local dist = (optpoint - cent).Magnitude
                        
                        local betweendist = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude * 0.3336
                        local betweendistSTUDS = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude
                        if dist <= aimfovcircle.Radius and dist < cdist and betweendist < aimdistance and betweendistSTUDS < ammodistance then
                            local canvis = isvisible(bot, potroot)
                            if canvis and isonscreen(potroot) then
                                cdist = dist
                                ctar = bot
                                cpart = potroot
                            end
                        end
                    end
                end
            end
        end
    end

    for _, pottar in ipairs(game.Players:GetPlayers()) do --priority 1 (players)
        if pottar ~= localplayer and pottar.Character and localplayer.Character.PrimaryPart ~= nil then
            if friendlistmode == "Blacklist" then 
                if table.find(aimFRIENDLIST, pottar.Name) ~= nil then
                    continue
                end
            elseif friendlistmode == "Whitelist" then 
                if table.find(aimFRIENDLIST, pottar.Name) == nil then
                    continue
                end
            end

            local potroot = chooseTpart(pottar.Character)
            if potroot then
                local spoint = wcamera:WorldToViewportPoint(potroot.Position)
                local optpoint = Vector2.new(spoint.X, spoint.Y)
                local dist = (optpoint - cent).Magnitude
                
                local betweendist = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude * 0.3336
                local betweendistSTUDS = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude
                if dist <= aimfovcircle.Radius and dist < cdist and betweendist < aimdistance and betweendistSTUDS < ammodistance then
                    local canvis = isvisible(pottar.Character, potroot)
                    if canvis and isonscreen(potroot) then
                        cdist = dist
                        ctar = pottar
                        cpart = potroot
                    end
                end
            end
        end
    end

    if ctar == nil then
        aimtarget = nil
        aimtargetpart = nil
    else
        aimtarget = ctar
        aimtargetpart = cpart
    end
end

aimmodfunc = function(prikol, p49, p50, p_u_51, _, p52, p53, p54, p55)
    local v_u_6 = game.ReplicatedStorage.Remotes.VisualProjectile
    local v_u_108 = 1
    local v_u_106 = 0
    local v_u_7 = game.ReplicatedStorage.Remotes.FireProjectile
    local target = aimtarget
    local target_part
    local v_u_4 = require(game.ReplicatedStorage.Modules:WaitForChild("FunctionLibraryExtension"))
    local v_u_15 = localplayer
    local v_u_115 = v_u_4:GetEstimatedCameraPosition(v_u_15)
    local v_u_103
    local v_u_114
    local v_u_16 = game.ReplicatedStorage.Players:FindFirstChild(v_u_15.Name)
    local v_u_64 = v_u_16.Status.GameplayVariables:GetAttribute("EquipId")
    local v_u_13 = game.ReplicatedStorage:WaitForChild("VFX")
    local v_u_2 = require(game.ReplicatedStorage.Modules:WaitForChild("VFX"))
    local v3 = require(game.ReplicatedStorage.Modules:WaitForChild("UniversalTables"))
    local v_u_5 = game.ReplicatedStorage.Remotes.ProjectileInflict
    local v_u_10 = game:GetService("ReplicatedStorage")
    local v_u_12 = v_u_10:WaitForChild("RangedWeapons")
    local v_u_17 = game.ReplicatedStorage.Temp
    local v_u_56 = v_u_15.Character
    local v135 = 500000
    local v_u_18 = v3.ReturnTable("GlobalIgnoreListProjectile")
    local v_u_115 = v_u_4:GetEstimatedCameraPosition(v_u_15)
    local v65 = v_u_10.AmmoTypes:FindFirstChild(p52)
    local v_u_74 = v65:GetAttribute("Pellets")
    local v60 = p50.ItemRoot
    local v61 = p49.ItemProperties
    local v62 = v_u_12:FindFirstChild(p49.Name)
    local v63 = v61:FindFirstChild("SpecialProperties")
    local v_u_66 = v63 and v63:GetAttribute("TracerColor") or v62:GetAttribute("ProjectileColor")
    local itemprop = require(v_u_16.Inventory:FindFirstChild(p49.Name).SettingsModule)
    local bulletspeed = v65:GetAttribute("MuzzleVelocity")
    local armorpen4 = v65:GetAttribute("ArmorPen")
    local tracerendpos = Vector3.zero
    local v79 = {
        ["x"] = {
            ["Value"] = 0
        },
        ["y"] = {
            ["Value"] = 0
        }
    }

    if v_u_56:FindFirstChild(p49.Name) then
        local v83 = 0.001 
        local v82 = 0.001
        local v81 = 10000
        if v61.Tool:GetAttribute("MuzzleDevice") or "Default" == "Suppressor" then
            if tick() - p53 < 0.8 then
                v_u_4:PlaySoundV2(v60.FireSoundSupressed, v60.FireSoundSupressed.TimeLength, v_u_17)
            else
                v_u_4:PlaySoundV2(v60.FireSoundSupressed, v60.FireSoundSupressed.TimeLength, v_u_17)
            end
        elseif tick() - p53 < 0.8 then
            v_u_4:PlaySoundV2(v60.FireSound, v60.FireSound.TimeLength, v_u_17)
        else
            v_u_4:PlaySoundV2(v60.FireSound, v60.FireSound.TimeLength, v_u_17)
        end
        local v_u_59
        if p_u_51.Item.Attachments:FindFirstChild("Front") then
            v_u_59 = p_u_51.Item.Attachments.Front:GetChildren()[1].Barrel
            local _ = p50.Attachments.Front:GetChildren()[1].Barrel
        else
            v_u_59 = p_u_51.Item.Barrel
            local _ = p50.Barrel
        end

        if target ~= nil and aimtargetpart ~= nil then
            target_part = aimtargetpart
            if aimtype == "Prediction" then
                local buldrop = v65:GetAttribute("ProjectileDrop")
                local bulsp = v65:GetAttribute("MuzzleVelocity")
                target_part = predictpos(target_part, bulsp, buldrop)
                v_u_103 = CFrame.new(v_u_115, target_part).LookVector
            else
                v_u_103 = CFrame.new(v_u_115, target_part.Position).LookVector
            end
            v_u_114 = v_u_103
        else
            target_part = p55
            v_u_103 = CFrame.new(v_u_115, v_u_15:GetMouse().Hit.Position).LookVector
            v_u_114 = v_u_103
        end

        function v185()
            local v_u_110 = RaycastParams.new()
            v_u_110.FilterType = Enum.RaycastFilterType.Exclude
            local v_u_111 = { v_u_56, p_u_51, v_u_18, aimignoreparts}
            v_u_110.FilterDescendantsInstances = v_u_111
            v_u_110.CollisionGroup = "WeaponRay"
            v_u_110.IgnoreWater = true

            v_u_106 += 1

            local usethisvec = v_u_114
            if aimdebug1 then
                usethisvec = Vector3.new(0,1,0)
            end

            if v_u_106 == 1 then
                task.spawn(function()
                    for i=1, multitaps do
                        if aimtype == "Instant Hit" then
                            if not v_u_7:InvokeServer(usethisvec, v_u_108, tick()-15) then 
                                game.ReplicatedStorage.Modules.FPS.Binds.AdjustBullets:Fire(v_u_64, 1)
                            end
                        else
                            if not v_u_7:InvokeServer(usethisvec, v_u_108, tick()) then 
                                game.ReplicatedStorage.Modules.FPS.Binds.AdjustBullets:Fire(v_u_64, 1)
                            end
                        end
                    end
                end)
            elseif 1 < v_u_106 then
                for i=1, multitaps do
                    v_u_6:FireServer(usethisvec, v_u_108)
                end
            end

            local v_u_131 = nil
            local v_u_132 = 0
            local v_u_133 = 0

            if (aimtype == "Prediction" or aimfakewait) and target ~= nil then
                local tpart 
                if target:IsA("Model") then
                    tpart = target.HumanoidRootPart
                else
                    tpart = target.Character.HumanoidRootPart
                end
                local velocity = tpart.Velocity
                local distance = (wcamera.CFrame.Position - tpart.CFrame.Position).Magnitude
                local tth = (distance / bulletspeed)
                task.wait(tth + 0.01)

                if aimtarget ~= nil and aimtargetpart ~= nil then
                    target_part = aimtargetpart
                    if aimtype == "Prediction" then
                        local buldrop = v65:GetAttribute("ProjectileDrop")
                        local bulsp = v65:GetAttribute("MuzzleVelocity")
                        target_part = predictpos(target_part, bulsp, buldrop)
                        v_u_103 = CFrame.new(v_u_115, target_part).LookVector
                    else
                        v_u_103 = CFrame.new(v_u_115, target_part.Position).LookVector
                    end
                    v_u_114 = v_u_103
                else
                    target_part = p55
                    v_u_103 = CFrame.new(v_u_115, v_u_15:GetMouse().Hit.Position).LookVector
                    v_u_114 = v_u_103
                end
            end

            local penetrated = false

            function v184(p134)
                v_u_132 = v_u_132 + p134
                if true then
                    v_u_133 = v_u_133 + v_u_132
                    local v136 = workspace:Raycast(v_u_115, v_u_114 * v135, v_u_110)
                    local v137 = nil
                    local v138 = nil
                    local v139 = nil
                    local v140
                    if v136 then
                        v137 = v136.Instance
                        v140 = v136.Position
                        v138 = v136.Normal
                        v139 = v136.Material
                    else
                        v140 = v_u_115 + v_u_114 * v135
                    end

                    if v137 == nil then
                        v_u_131:Disconnect()
                        return
                    end

                    tracerendpos = v140

                    local v171 = v_u_4:FindDeepAncestor(v137, "Model")
                    if v171:FindFirstChild("Humanoid") then -- if hit target
                        local ran = math.random(1, 100)
                        local ranbool = ran <= aimchance
                        if ranbool then
                            local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))

                            if target_part and penetrated == false then
                                v_u_5:FireServer(target_part, v175, v_u_108, tick())
                            else
                                v_u_5:FireServer(v137, v175, v_u_108, tick())
                            end
                        else
                            local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))
                            v_u_5:FireServer(p55, v175, v_u_108, tick())
                        end

                        v_u_2.Impact(v137, v140, v138, v139, v_u_114, "Ranged", true)
                    elseif v137.Name == "Terrain" then -- if hit terrain
                        local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))
                        v_u_5:FireServer(v137, v175, v_u_108, tick())

                        v_u_2.Impact(v137, v140, v138, v139, v_u_114, "Ranged", true)
                    else -- if hit not target then try wallpen
                        v_u_2.Impact(v137, v140, v138, v139, v_u_114, "Ranged", true)

                        local arg1, arg2, arg3 = v_u_4.Penetration(v_u_4, v137, v140, v_u_114, armorpen4)
                        if arg1 == nil or arg2 == nil then
                            local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))
                            v_u_5:FireServer(v137, v175, v_u_108, tick())
                            v_u_131:Disconnect()
                            return
                        end

                        armorpen4 = arg1
                        if armorpen4 > 0 then
                            v_u_115 = arg2
                            v_u_2.Impact(unpack(arg3))
                            penetrated = true
                            return
                        end

                        v_u_131:Disconnect()
                        return
                    end
                end

                v_u_131:Disconnect()
                return
            end
            v_u_131 = game:GetService("RunService").RenderStepped:Connect(v184)
            return
        end
        if v_u_74 == nil then
            task.spawn(v185)
        else
            for _ = 1, v_u_74 do
                task.spawn(v185)
            end
        end

        if tracbool then
            task.spawn(function()
                task.wait(0.05)
                if tracerendpos == Vector3.zero then return end
                runtracer(v60.Position, tracerendpos)
            end)
        end

        return v83, v82, v81, v79
    end
end

--esp--
print("loading ESP functions/connections")
local function setupesp(obj, dtype, otype1)
    if not obj then return end

    local dobj
    local tableinfo
    if dtype == "Name" then
        dobj = Drawing.new("Text")
        dobj.Visible = espbool
        dobj.Center = true
        dobj.Outline = true
        dobj.Size = esptextsize
        dobj.Color = esptextcolor
        dobj.OutlineColor = Color3.new(0, 0, 0)
        tableinfo = {
            primary = obj,
            type = "Name",
            otype = otype1
        }
    elseif dtype == "HP" then
        dobj = Drawing.new("Text")
        dobj.Visible = espbool
        dobj.Center = true
        dobj.Outline = true
        dobj.Size = esptextsize
        dobj.Color = esptextcolor
        dobj.OutlineColor = Color3.new(0, 0, 0)
        tableinfo = {
            primary = obj,
            type = "HP",
            otype = otype1
        }
    elseif dtype == "Distance" then
        dobj = Drawing.new("Text")
        dobj.Visible = espbool
        dobj.Center = true
        dobj.Outline = true
        dobj.Size = esptextsize
        dobj.Color = esptextcolor
        dobj.OutlineColor = Color3.new(0, 0, 0)
        tableinfo = {
            primary = obj,
            type = "Distance",
            otype = otype1
        }
    elseif dtype == "Hotbar" then
        dobj = Drawing.new("Text")
        dobj.Visible = espbool
        dobj.Center = true
        dobj.Outline = true
        dobj.Size = esptextsize
        dobj.Color = esptextcolor
        dobj.OutlineColor = Color3.new(0, 0, 0)
        tableinfo = {
            primary = obj,
            type = "Hotbar",
            otype = otype1
        }
    elseif dtype == "Highlight" then
        dobj = Instance.new("Highlight")
        dobj.Name = "lovelyx highlight solter dont delete PLS"
        dobj.FillColor = espfillcolor
        dobj.OutlineColor = esplinecolor
        dobj.FillTransparency = espchamsfill
        dobj.OutlineTransparency = espchamsline
        if obj.Parent:IsA("Model") then
            dobj.Parent = obj.Parent
        else
            dobj:Destroy()
            return
        end

        dobj.Enabled = esphigh
        tableinfo = {
            primary = obj,
            type = "Highlight",
            otype = otype1
        }
    end

    if dobj == nil or tableinfo == nil then return end

    local function selfdestruct() --destroy esp object
        if dtype == "Highlight" then
            dobj.Enabled = false
            dobj:Destroy()
        else
            dobj.Visible = false
            dobj:Remove()
        end
        if removing then
            removing:Disconnect()
            removing = nil
        end
        return
    end

    if esptable[dobj] ~= nil then --if in table then cancel
        selfdestruct()
        return
    else
        esptable[dobj] = tableinfo
    end

    removing = workspace.DescendantRemoving:Connect(function(what)
        if what == obj then
            esptable[dobj] = nil
            selfdestruct()
        end
    end)
end
local function startesp(v, otype) --start esp for model
    if not v then return end

    task.spawn(function()
        if otype == "Extract" then
            setupesp(v, "Name", otype)
            setupesp(v, "Distance", otype)
        elseif otype == "Loot" then
            local Amount
            local TotalPrice = 0
            local Value = 0

            if v.Parent and v.Parent:FindFirstChild("Inventory") then else
                return
            end

            for _, i in ipairs(v.Parent.Inventory:GetChildren()) do
                Amount = i.ItemProperties:GetAttribute("Amount") or 1
                TotalPrice += i.ItemProperties:GetAttribute("Price") or 0
                Value += (valcache[i.ItemProperties:GetAttribute("CallSign")] or 0) * Amount
            end --original = https://rbxscript.com/post/ProjectDeltaLootEsp-P7xaS

            if Value >= 4 then
                setupesp(v, "Name", otype)
                setupesp(v, "Hotbar", otype)
                setupesp(v, "Distance", otype)
            end
        elseif otype == "Dead333" then
            local hd = v:WaitForChild("Head",1)
            if hd == nil then return end
            setupesp(hd, "Name", otype)
            setupesp(hd, "Distance", otype)
        else
            local hd = v:WaitForChild("Head",1)
            if hd == nil then return end
            setupesp(hd, "Name", otype)
            setupesp(hd, "HP", otype)
            setupesp(hd, "Distance", otype)
            setupesp(hd, "Hotbar", otype)
            setupesp(hd, "Highlight", otype) 
        end
    end)
end
for i,v in ipairs(workspace:GetDescendants()) do
    if v and v:FindFirstChild("Humanoid") and v ~= localplayer.Character then
        if game.Players:FindFirstChild(v.Name) and not v:FindFirstAncestor("DroppedItems") then
            startesp(v, "Plr")
        elseif v:FindFirstAncestor("AiZones") then
            startesp(v, "Bot333")
        elseif v:FindFirstAncestor("DroppedItems") then
            startesp(v, "Dead333")
        end
    elseif v.Parent == workspace:FindFirstChild("NoCollision"):FindFirstChild("ExitLocations") then
        startesp(v, "Extract")
    elseif v:FindFirstAncestor("Containers") and v:IsA("MeshPart") then
        if v.Parent:IsA("Model") then
            startesp(v, "Loot")
        end
    end
end
workspace.DescendantAdded:Connect(function(v)
    if v and v.Parent and v:IsA("BasePart") and v.Name == "Head" then
        local hum = v.Parent:WaitForChild("Humanoid", 2)
        if hum and v.Parent ~= localplayer.Character then
            if game.Players:FindFirstChild(v.Parent.Name) and not v:FindFirstAncestor("DroppedItems") then
                startesp(v.Parent, "Plr")
            elseif v:FindFirstAncestor("AiZones") then
                startesp(v.Parent, "Bot333")
            elseif v:FindFirstAncestor("DroppedItems") then
                startesp(v.Parent, "Dead333")
            end
        end
    elseif v.Parent == workspace:FindFirstChild("NoCollision"):FindFirstChild("ExitLocations") then
        startesp(v, "Extract")
    elseif v:FindFirstAncestor("Containers") and v:IsA("MeshPart") then
        if v.Parent:IsA("Model") then
            startesp(v, "Loot")
        end
    end
end)


--no jump cd--
print("loading bunnyhop function")
function startnojumpcd() --btw this not paste i found it myself
    while nojumpcd do
        task.wait(0.01)
        if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
            game.Players.LocalPlayer.Character.Humanoid:SetAttribute("JumpCooldown", tick())
        else
            wait(1)
        end
    end
end
--camera--
print("loading fov changer")
do --fov changer
    local csys = require(game.ReplicatedStorage.Modules.CameraSystem)
    local dop2 = require(game.ReplicatedStorage.Modules.spring).new(Vector3.new(), Vector3.new(), Vector3.new(), 15, 0.5)
    local dop3 = game:GetService("TweenService")
    local dop4 = workspace.Camera
    local dop5 = false
    local dop6 = 1
    local dop7 = false
    local dop8 = 1
    local dop9 = 1
    local dop10 = nil
    local function FieldOfViewUpdate(p11, p12, p13) 
        local v14 = p12 or Enum.EasingStyle.Quad
        local v15 = p13 or Enum.EasingDirection.Out
        local targetfov
        if dop8 > 1 then
            targetfov = zoomfov
        else
            targetfov = basefov
        end
        local v16 = dop9 ~= 1 and dop9 or dop5 and dop6 or targetfov
        dop3:Create(dop4, TweenInfo.new(p11, v14, v15), {
            ["FieldOfView"] = v16 > 1 and dop7 and v16 or v16
        }):Play()
        if dop10 then
            local v_u_17 = dop10
            task.spawn(function() 
                local v_u_18 = v_u_17:FindFirstChild("Head") or v_u_17.PrimaryPart
                dop2.p = v_u_18.Position
                local v_u_19 = nil
                v_u_19 = game:GetService("RunService").RenderStepped:Connect(function(p20)
                    dop4.CFrame = CFrame.lookAt(dop4.CFrame.Position, dop2.p)
                    dop2.target = v_u_18.Position
                    dop2:update(p20)
                    if dop10 ~= v_u_17 then
                        v_u_19:Disconnect()
                    end
                end)
            end)
        end
    end
    camzoomfunction = function(_, p21, p22, p23, p24, p25)
        dop7 = p22
        dop8 = p21
        FieldOfViewUpdate(p23, p24, p25)
    end
end


-- third person --
print("changing thirdperson roblox script")
require(game.Players.LocalPlayer.PlayerScripts.PlayerModule.CameraModule.TransparencyController).Update = function(a1, a2) -- transparency = 0
    local v14_3_ = workspace
    local v14_2_ = v14_3_.CurrentCamera

    local setto = 0
    if camthirdp == false then
        setto = 1
    end

    if v14_2_ then
        v14_3_ = a1.enabled
        if v14_3_ then
            local v14_6_ = v14_2_.Focus
            local v14_5_ = v14_6_.p
            local v14_7_ = v14_2_.CoordinateFrame
            v14_6_ = v14_7_.p
            local v14_4_ = v14_5_ - v14_6_
            v14_3_ = v14_4_.magnitude
            v14_5_ = 2
            v14_4_ = 0
            v14_5_ = 0.500000
            if v14_4_ < v14_5_ then
                v14_4_ = 0
            end
            v14_5_ = a1.lastTransparency
            if v14_5_ then
                v14_5_ = 1
                if v14_4_ < v14_5_ then
                    v14_5_ = a1.lastTransparency
                    v14_6_ = 0.950000
                    if v14_5_ < v14_6_ then
                        v14_6_ = a1.lastTransparency
                        v14_5_ = v14_4_ - v14_6_
                        v14_7_ = 2.800000
                        v14_6_ = v14_7_ * a2
                        local v14_9_ = -v14_6_
                        local v14_8_ = v14_5_
                        local v14_10_ = v14_6_
                        local clamp = math.clamp
                        v14_7_ = clamp(v14_8_, v14_9_, v14_10_)
                        v14_5_ = v14_7_
                        v14_7_ = a1.lastTransparency
                        v14_4_ = v14_7_ + v14_5_
                    else
                        v14_5_ = true
                        a1.transparencyDirty = v14_5_
                    end
                else
                    v14_5_ = true
                    a1.transparencyDirty = v14_5_
                end
            else
                v14_5_ = true
                a1.transparencyDirty = v14_5_
            end
            v14_7_ = v0_2_
            v14_7_ = v14_4_
            local v14_8_ = 2
            v14_7_ = 0
            v14_8_ = 1
            v14_4_ = v14_5_
            v14_5_ = a1.transparencyDirty
            if not v14_5_ then
                v14_5_ = a1.lastTransparency
                if v14_5_ ~= v14_4_ then
                    v14_5_ = pairs
                    v14_6_ = a1.cachedParts
                    v14_5_, v14_6_, v14_7_ = v14_5_(v14_6_)
                    for v14_8_, v14_9_ in v14_5_, v14_6_, v14_7_ do
                        local v14_11_ = v0_0_
                        local v14_10_ = false
                        if v14_10_ then
                            v14_11_ = v0_0_
                            v14_10_ = v14_11_.AvatarGestures
                            if v14_10_ then
                                v14_10_ = {}
                                local Hat = Enum.AccessoryType.Hat
                                local v14_12_ = true
                                v14_10_[Hat] = v14_12_
                                local Hair = Enum.AccessoryType.Hair
                                v14_12_ = true
                                v14_10_[Hair] = v14_12_
                                local Face = Enum.AccessoryType.Face
                                v14_12_ = true
                                v14_10_[Face] = v14_12_
                                local Eyebrow = Enum.AccessoryType.Eyebrow
                                v14_12_ = true
                                v14_10_[Eyebrow] = v14_12_
                                local Eyelash = Enum.AccessoryType.Eyelash
                                v14_12_ = true
                                v14_10_[Eyelash] = v14_12_
                                v14_11_ = v14_8_.Parent
                                local v14_13_ = "Accessory"
                                v14_11_ = v14_11_:IsA(v14_13_)
                                if v14_11_ then
                                    v14_13_ = v14_8_.Parent
                                    v14_12_ = v14_13_.AccessoryType
                                    v14_11_ = v14_10_[v14_12_]
                                    if not v14_11_ then
                                        v14_11_ = v14_8_.Name
                                        if v14_11_ == "Head" then
                                            v14_8_.LocalTransparencyModifier = setto
                                        else
                                            v14_11_ = 0
                                            v14_8_.LocalTransparencyModifier = setto
                                            v14_8_.LocalTransparencyModifier = setto
                                        end
                                    end
                                end
                                v14_11_ = v14_8_.Name
                                if v14_11_ == "Head" then
                                    v14_8_.LocalTransparencyModifier = setto
                                else
                                    v14_11_ = 0
                                    v14_8_.LocalTransparencyModifier = setto
                                    v14_8_.LocalTransparencyModifier = setto
                                end
                            else
                                v14_8_.LocalTransparencyModifier = setto
                            end
                        else
                            v14_8_.LocalTransparencyModifier = setto
                        end
                    end
                    v14_5_ = false
                    a1.transparencyDirty = v14_5_
                    a1.lastTransparency = setto
                end
            end
            v14_5_ = pairs
            v14_6_ = a1.cachedParts
            v14_5_, v14_6_, v14_7_ = v14_5_(v14_6_)
            for v14_8_, v14_9_ in v14_5_, v14_6_, v14_7_ do
                local v14_11_ = v0_0_
                local v14_10_ = false
                if v14_10_ then
                    v14_11_ = v0_0_
                    v14_10_ = v14_11_.AvatarGestures
                    if v14_10_ then
                        v14_10_ = {}
                        local Hat = Enum.AccessoryType.Hat
                        local v14_12_ = true
                        v14_10_[Hat] = v14_12_
                        local Hair = Enum.AccessoryType.Hair
                        v14_12_ = true
                        v14_10_[Hair] = v14_12_
                        local Face = Enum.AccessoryType.Face
                        v14_12_ = true
                        v14_10_[Face] = v14_12_
                        local Eyebrow = Enum.AccessoryType.Eyebrow
                        v14_12_ = true
                        v14_10_[Eyebrow] = v14_12_
                        local Eyelash = Enum.AccessoryType.Eyelash
                        v14_12_ = true
                        v14_10_[Eyelash] = v14_12_
                        v14_11_ = v14_8_.Parent
                        local v14_13_ = "Accessory"
                        v14_11_ = v14_11_:IsA(v14_13_)
                        if v14_11_ then
                            v14_13_ = v14_8_.Parent
                            v14_12_ = v14_13_.AccessoryType
                            v14_11_ = v14_10_[v14_12_]
                            if not v14_11_ then
                                v14_11_ = v14_8_.Name
                                if v14_11_ == "Head" then
                                    v14_8_.LocalTransparencyModifier = setto
                                else
                                    v14_11_ = 0
                                    v14_8_.LocalTransparencyModifier = setto
                                    v14_8_.LocalTransparencyModifier = setto
                                end
                            end
                        end
                        v14_11_ = v14_8_.Name
                        if v14_11_ == "Head" then
                            v14_8_.LocalTransparencyModifier = setto
                        else
                            v14_11_ = 0
                            v14_8_.LocalTransparencyModifier = setto
                            v14_8_.LocalTransparencyModifier = setto
                        end
                    else
                        v14_8_.LocalTransparencyModifier = setto
                    end
                else
                    v14_8_.LocalTransparencyModifier = setto
                end
            end
            v14_5_ = false
            a1.transparencyDirty = v14_5_
            a1.lastTransparency = setto
        end
    end
end






--esp map--
print("loading espmap function")
handleESPMAP = function(bool)
    if bool then
        local map = game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.MainFrame.Maps.EstonianBorderMap
        local mapFrame = game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.MainFrame
        mapFrame.Size = UDim2.fromScale(1, 1)
        mapFrame.Position = UDim2.new(0.5, 0, 0.49, 0)

        mapFrame.Parent.Visible = true
        game.UserInputService.MouseIconEnabled = true
        game.Players.LocalPlayer.PlayerGui.MainGui.ModalButton.Modal = true

        for _,v in ipairs(mapFrame.Markers:GetChildren()) do
            v:Destroy()
        end

        local selfMarker = game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.MainFrame.MarkerDotTemplate:Clone()
        selfMarker.Name = "SelfMarker"
        selfMarker.Visible = true
        selfMarker.Parent = game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.MainFrame.Markers
        selfMarker.TextLabel.Visible = true
        espmapmarkers.Me = {
            playerRef = game.Players.LocalPlayer,
            markerRef = selfMarker,
        }

        for _,v in ipairs(game.Players:GetChildren()) do
            if v ~= localplayer then
                local plrMarker = game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.MainFrame.MarkerDotTemplate:Clone()
                plrMarker.ImageColor3 = Color3.fromRGB(227, 36, 36)
                plrMarker.Name = "TeamMarker"
                plrMarker.Visible = true
                plrMarker.TextLabel.Text = v.Name
                plrMarker.TextLabel.Visible = true
                plrMarker.TextLabel.Size = UDim2.fromScale(2, 0.5)
                plrMarker.TextLabel.Position = UDim2.fromScale(-0.5, 0)
                plrMarker.Parent = game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.MainFrame.Markers
                espmapmarkers[v.Name] = {
                    playerRef = v,
                    markerRef = plrMarker,
                }
            end
        end
        
        task.spawn(function()
            while task.wait(0.1) do
                if espmapactive == false then return end

                for ind, markerData in espmapmarkers do
                    if markerData.markerRef == nil then
                        table.remove(espmapmarkers, ind)
                    else
                        local playerRef = markerData.playerRef
                        if playerRef then
                            local character = playerRef.Character
                            if character then
                                local chpos = game.ReplicatedStorage.Players:FindFirstChild(playerRef.Name).Status.UAC:GetAttribute("LastVerifiedPos")
                                local xPos = (chpos.X - 208) / map:GetAttribute("SizeReal")
                                local zPos = (chpos.Z + 203) / map:GetAttribute("SizeReal")
                                markerData.markerRef.Position = UDim2.new(0.5 + xPos, 0, 0.5 + zPos, 0)
                                markerData.markerRef.Visible = true
                                if markerData.playerRef ~= localplayer then 
                                    if table.find(aimFRIENDLIST, markerData.playerRef.Name) ~= nil then
                                        markerData.markerRef.ImageColor3 = Color3.fromRGB(102, 245, 66)
                                    else
                                        markerData.markerRef.ImageColor3 = Color3.fromRGB(227, 36, 36)
                                    end
                                end
                            else
                                markerData.markerRef.Visible = false
                            end
                        end
                    end
                end
            end
        end)

        mapFrame.Markers.Visible = true
    else
        if game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.Visible == true then
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.MapFrame.Visible = false
            game.Players.LocalPlayer.PlayerGui.MainGui.ModalButton.Modal = false
            game.UserInputService.MouseIconEnabled = false
        end
    end
end



--anticheat bypass--
print("loading client anticheat bypass")  --method by discord.gg/exothium
local function handleClientAntiCheatBypass()
    if ACBYPASS_SYNC == true then return end

    local mt = getrawmetatable(game)
    local oldNamecall = mt.__namecall
    setreadonly(mt, false)
    mt.__namecall = newcclosure(function(self, ...)
        local Method = getnamecallmethod()
        local Args = {...}
        if Method == "FireServer" and self.Name == "ProjectileInflict" and true then
            if Args[1] == game.Players.LocalPlayer.Character.HumanoidRootPart then
                return coroutine.yield()
            end
        end
        return oldNamecall(self, ...)
    end)
    setreadonly(mt, true)

    ACBYPASS_SYNC = true
end
handleClientAntiCheatBypass()


--selftrack(ping check)
print("loading ping check")
for i = 10, 1000, 10 do
    selftrack_data[i] = localplayer.Character.Head.Position
end
local function updateselfpos()
    for time = 990, 10, -10 do
        selftrack_data[time + 10] = selftrack_data[time]
    end
    selftrack_data[10] = localplayer.Character.Head.Position
end


--thirdperson fix--
local function ThirdPersonFix()
    local mt = getrawmetatable(game)
    local oldIndex = mt.__newindex
    setreadonly(mt, false)
    mt.__newindex = newcclosure(function(self, index, value)
        if tostring(self) == "Humanoid" and index == "CameraOffset" and camthirdp == true then
            return oldIndex(self, index, Vector3.new(camthirdpX, camthirdpY, camthirdpZ))
        end
        return oldIndex(self, index, value)
    end)
    setreadonly(mt, true)
end
ThirdPersonFix()


-


--global cycle--
print("loading global cycles")

task.spawn(function() -- very slow
    while wait(10.5) do
        --library:ChangeWeb((string.char(100,111,115,99,111,114,100,46,103,103,47,97,114,100,111,117,114)))
        table.clear(aimignoreparts)
        for i,v in ipairs(workspace:GetDescendants()) do
            if v:GetAttribute("PassThrough") then
                table.insert(aimignoreparts, v)
            end
        end
    end
end)

task.spawn(function() -- slow
    while wait(1) do
        invchecktext.Position = Vector2.new(30, (wcamera.ViewportSize.Y / 2) - 230) --on screen stuff

        if scselected ~= nil and scgui ~= nil then
            scgui.SkinsLabel.Text = "Available skins (For ".. scselected.Name.." ) : "
        else
            scgui.SkinsLabel.Text = "Available skins (For None) : "
        end

        local function handleModDetect()
            if detectmods then
                for _, player in ipairs(game.Players:GetPlayers()) do
                    if detectedmods[player.Name] then continue end

                    local pinfo = game.ReplicatedStorage.Players:FindFirstChild(player.Name)
                    if not pinfo then continue end

                    if pinfo.UAC:GetAttribute("Enabled") == true then
                        detectedmods[player.Name] = true
                        Notify("Mod Detected", "UAC Enabled ( ".. player.Name .." ) ")
                        continue
                    end
                    if pinfo.Status.GameplayVariables:GetAttribute("Godmode") == true then
                        detectedmods[player.Name] = true
                        Notify("Mod Detected", "Godmode Enabled ( ".. player.Name .." ) ")
                        continue
                    end
                end
            end
        end


        local function handleInventory()
            if viewmodoffset == false then return end

            local offset = CFrame.new(Vector3.new(viewmodX, viewmodY, viewmodZ))
            if not offset then return end

            local inv = game.ReplicatedStorage.Players:FindFirstChild(localplayer.Name).Inventory
            if not inv then return end

            for _, v in pairs(inv:GetChildren()) do
                if not v:FindFirstChild("SettingsModule") then return end
                local sett = require(v.SettingsModule)
                sett.weaponOffSet = offset
                if rapidfire then
                    sett.FireRate = 0.001
                end
                if unlockmodes then
                    sett.FireModes = {"Auto", "Semi"}
                end
            end
        end

        handleInventory()
    end
end)

runs.RenderStepped:Connect(function(delta) --  fast
    --runs.RenderStepped:Wait()
    if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") or not localplayer.Character:FindFirstChild("Humanoid") then
        return
    end


    local nil1, nil2, newglobalcurrentgun = getcurrentgun(localplayer)
    globalcurrentgun = newglobalcurrentgun
    globalammo = getcurrentammo(globalcurrentgun)


    if aimtrigger and aimtarget ~= nil and not uis.MouseIconEnabled then -- triggerbot
        task.spawn(function()
            mouse1press()
            wait()
            mouse1release()
        end)
    end



    if aimdynamicfov then -- fov changer
        aimfovcircle.Radius = aimfov * (80 / wcamera.FieldOfView )
    else
        aimfovcircle.Radius = aimfov
    end


    --ping check part
    selftrack_update += delta
    if selftrack_update >= 0.01 then
        updateselfpos(selftrack_update)
        selftrack_update = 0
    end


    choosetarget() --aim part


    if aimtarget ~= nil and aimtargetpart ~= nil then --on screen stuff
        aimtargetname.Text = aimtarget.Name

        local thum = aimtargetpart.Parent.Humanoid
        local thealth = thum.Health
        local shotsleft = nil
        if globalammo ~= nil then
            local gundmg = globalammo:GetAttribute("Damage")
            shotsleft = math.floor(thealth / gundmg)
        end

        if shotsleft ~= nil then
            aimtargetshots.Text = "abt " .. shotsleft .. " shots left to kill [without armor]"
        else
            aimtargetshots.Text = ""
        end
    else
        aimtargetname.Text = "None"
        aimtargetshots.Text = " "
    end
    aimtargetname.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2 + aimfov + 20)
    aimtargetshots.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2 + aimfov + 50)
    aimfovcircle.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
    if scgui then
        scgui.Position = librarymaingui.Position + UDim2.new(0.16, 0, 0, 0)
    end


    if invcheck and aimtarget ~= nil then --inv checker
        local profile = game.ReplicatedStorage.Players:FindFirstChild(aimtarget.Name)
        if profile then
            local cloth = profile.Clothing
            local inv = profile.Inventory
            local result = ""
    
            for _, item in ipairs(inv:GetChildren()) do
                result = result .. item.Name .. ",\n"
            end
            for _, item in ipairs(cloth:GetChildren()) do
                local itemName = item.Name
                local inventory = item:FindFirstChild("Inventory")
    
                if inventory then
                    result = result .. itemName .. " = {\n"
                    local count = 0
                    for _, invItem in ipairs(inventory:GetChildren()) do
                        local invcount = invItem.ItemProperties:GetAttribute("Amount")
                        count = count + 1
                        if count % 2 == 0 then
                            if invcount and invcount > 1 then
                                result = result .. " " .. invItem.Name .."[x".. invcount .."]".. ","
                            else
                                result = result .. " " .. invItem.Name .. ","
                            end
                            result = result .. "\n"
                        else
                            if invcount and invcount > 1 then
                                result = result .. "    " .. invItem.Name .."[x".. invcount .."]".. ","
                            else
                                result = result .. "    " .. invItem.Name .. ","
                            end
                        end
                    end
                    result = result:sub(1, -2) .. "\n},\n"
                else
                    result = result .. itemName .. ",\n"
                end
            end

            result = result:sub(1, -3)
            result = aimtarget.Name.."'s inventory:\n" .. result
    
            invchecktext.Text = result
        else
            invchecktext.Text = " "
        end
    else
        invchecktext.Text = " "
    end


    for dobj, info in esptable do --esp part
        local dtype = info.type
        local otype = info.otype
        
        if info.primary == nil or info.primary.Parent == nil then
            esptable[dobj] = nil
            if dtype == "Highlight" then
                dobj.Enabled = false
                dobj:Destroy()
            else
                dobj.Visible = false
                dobj:Remove()
            end
            continue
        end

        local obj
        local isHumanoid
        if otype == "Extract" then
            obj = info.primary
            isHumanoid = true
        elseif otype == "Loot" then
            obj = info.primary
            isHumanoid = true
        else
            obj = info.primary.Parent:FindFirstChild("UpperTorso")
            if not obj then
                esptable[dobj] = nil
                if dtype == "Highlight" then
                    dobj.Enabled = false
                    dobj:Destroy()
                else
                    dobj.Visible = false
                    dobj:Remove()
                end
                continue
            end
            isHumanoid = obj.Parent:FindFirstChild("Humanoid")
        end

        if (otype == "Bot333" and espbots == false) or (otype == "Dead333" and espdead == false) or (otype == "Extract" and espexit == false) or (otype == "Loot" and esploot == false) then
            if dtype == "Highlight" then
                dobj.Enabled = false
            else
                dobj.Visible = false
            end
            continue
        end

        if localplayer.Character == nil or localplayer.Character.PrimaryPart == nil then
            if dtype == "Highlight" then
                dobj.Enabled = false
            else
                dobj.Visible = false
            end
            continue
        end
        
        if otype == "Bot333" and obj.Parent.Humanoid.Health == 0 then
            info.otype = "Dead333"
        end

        local metersdist = math.floor((localplayer.Character.PrimaryPart.Position - obj.Position).Magnitude * 0.3336)
        local studsdist = math.floor((localplayer.Character.PrimaryPart.Position - obj.Position).Magnitude)

        if espbool and isonscreen(obj) and isHumanoid and metersdist < esprenderdist then
            local headpos = wcamera:WorldToViewportPoint(obj.Position)
            local resultpos = Vector2.new(headpos.X, headpos.Y)
    
            if dtype == "Name" then
                if espname then
                    resultpos = resultpos - Vector2.new(0, 15)
                    if otype == "Extract" then
                        dobj.Text = obj.Name
                    elseif otype == "Dead333" then 
                        dobj.Text = obj.Parent.Name .. " [DEAD]"
                    else
                        dobj.Text = obj.Parent.Name
                    end
                    dobj.Position = resultpos
                    dobj.Size = esptextsize
                    dobj.Color = esptextcolor
                    dobj.Outline = esptextline
                    dobj.Visible = true
                else
                    dobj.Visible = false
                end
            elseif dtype == "HP" then

                if otype == "Dead333" then
                    dobj.Visible = false
                    continue
                end

                resultpos = resultpos - Vector2.new(0, 30)
                dobj.Text = math.floor(obj.Parent.Humanoid.Health) .. "HP"
                dobj.Position = resultpos
                dobj.Size = esptextsize
                dobj.Color = esptextcolor
                dobj.Visible = esphp
                dobj.Outline = esptextline
            elseif dtype == "Distance" then
                if espdistance then
                    resultpos = resultpos - Vector2.new(0, 45)
                    if espdistmode == "Meters" then
                        dobj.Text = metersdist .. "m"
                    elseif espdistmode == "Studs" then
                        dobj.Text = studsdist .. "s"
                    end
                    dobj.Position = resultpos
                    dobj.Size = esptextsize
                    dobj.Color = esptextcolor
                    dobj.Outline = esptextline
                    dobj.Visible = true
                else
                    dobj.Visible = false
                end
            elseif dtype == "Hotbar" then

                if otype == "Dead333" then
                    dobj.Visible = false
                    continue
                end

                resultpos = resultpos + Vector2.new(0, 15)
                local hotgun = "None"
                for _, v in ipairs(obj.Parent:GetChildren()) do
                    if v:FindFirstChild("ItemRoot") then
                        hotgun = v.Name
                        break
                    end
                end

                dobj.Visible = esphotbar
                if otype == "Loot" then
                    local Amount
                    local TotalPrice = 0
                    local Value = 0

                    for _, h in ipairs(obj.Parent.Inventory:GetChildren()) do
                        Amount = h.ItemProperties:GetAttribute("Amount") or 1
                        TotalPrice += h.ItemProperties:GetAttribute("Price") or 0
                        Value += (valcache[h.ItemProperties:GetAttribute("CallSign")] or 0) * Amount
                    end --original = https://rbxscript.com/post/ProjectDeltaLootEsp-P7xaS

                    if Value >= 20 then
                        dobj.Text = "Rate : Godly | " .. TotalPrice .. "$"
                    elseif Value >= 12 then
                        dobj.Text = "Rate : Good | " .. TotalPrice .. "$"
                    elseif Value >= 8 then
                        dobj.Text = "Rate : Not bad | " .. TotalPrice .. "$"
                    elseif Value >= 4 then
                        dobj.Text = "Rate : Bad | " .. TotalPrice .. "$"
                    end
                else
                    dobj.Text = hotgun
                end
                dobj.Position = resultpos
                dobj.Size = esptextsize
                dobj.Outline = esptextline
                dobj.Color = esptextcolor
            elseif dtype == "Highlight" then
                if otype == "Dead333" or obj == nil or obj.Parent == nil or not obj.Parent:IsA("Model") or obj.Parent.Humanoid.Health < 1 then
                    esptable[dobj] = nil
                    dobj.Enabled = false
                    dobj:Destroy()
                    continue
                end

                dobj.FillColor = espfillcolor
                dobj.OutlineColor = esplinecolor
                dobj.FillTransparency = espchamsfill
                dobj.OutlineTransparency = espchamsline
                dobj.Enabled = esphigh
            end
        else
            if dtype == "Highlight" then
                dobj.Enabled = false
            else
                dobj.Visible = false
            end
        end
    end
end)

--loaded--
scriptloading = false

print("loaded")
Notify("lovelyx", "Script loaded")
game.CoreGui.PCR_1.Enabled = not game.CoreGui.PCR_1.Enabled
